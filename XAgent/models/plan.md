# ClassDef PlanOperation
**PlanOperation 类的功能**：这个类代表计划操作的结构。

PlanOperation 类是一个用于表示计划中操作的结构的类。它继承自 BaseContext，用于定义计划操作的相关属性和行为。

PlanOperation 类包含以下属性：
- `operation`：一个字符串，表示操作的类型，可以是 "split"、"add"、"delete" 或 "exit" 中的一个。
- `target_task_id`：一个字符串，表示目标任务的 ID。
- `subtasks`：一个 Task 类型的列表，表示子任务。

在项目中，PlanOperation 类的实例用于执行计划树中的操作。例如，在 XAgent/engines/plan.py 文件中，PlanOperation 类的实例用于处理工具调用，并根据操作类型对计划树进行修改。

具体的调用情况如下：
- 当操作类型为 'exit' 时，表示退出计划修正过程。
- 当操作类型为 'split' 时，表示将目标任务分割为多个子任务。
- 当操作类型为 'add' 时，表示在目标任务后添加新的任务。
- 当操作类型为 'delete' 时，表示删除目标任务。

在处理操作时，会根据操作的类型和目标任务的状态进行相应的处理。例如，如果目标任务的深度太深或太浅，或者目标任务的宽度太宽，会返回错误状态并且不执行操作。如果目标任务不是待办任务，也不会执行删除操作。

**注意事项**：
- 在使用 PlanOperation 类时，需要确保 `operation` 属性的值是有效的操作类型。
- `target_task_id` 必须是计划树中存在的任务 ID。
- 在执行操作之前，应该检查目标任务的状态和位置，以确保操作的合法性和可行性。
- `subtasks` 属性中的任务应该是有效的 Task 实例，并且在执行 'split' 或 'add' 操作时会被用作新添加的子任务。
***
# ClassDef PlanNode
**PlanNode函数**: 这个类的功能是表示计划树中的一个节点，用于存储任务的信息和状态。

**model_dump()函数**: 将PlanNode对象转换为字典格式的数据，以便进行存储或传输。

**get_task(id)函数**: 根据给定的id获取对应的任务节点。

**traversal()函数**: 对计划树进行遍历，返回按顺序排列的所有节点。

**get_next()函数**: 获取计划树中下一个待执行的子任务。

**get_current()函数**: 获取计划树中当前正在执行的子任务。

**get_remining()函数**: 获取计划树中剩余的子任务。

**__str__()函数**: 将计划树以字符串形式打印出来，包括节点的id、名称、目标、状态等信息。

**注意**: 在使用PlanTree类时，需要先创建根节点，并通过add_child()方法添加子节点。

**输出示例**:
```
[id] 1
[name] Root
[goal] Find primes below 100
[status] TODO

[id] 1.1
[name] Subtask 1
[goal] Find prime numbers
[status] TODO

[id] 1.2
[name] Subtask 2
[goal] Analyze prime numbers
[status] TODO
```

**注意**: 在使用PlanTree类时，需要先创建根节点，并通过add_child()方法添加子节点。
## FunctionDef dump_task
**dump_task函数**：这个函数的功能是将当前任务节点及其子节点的信息转化为字典形式。

该函数是PlanNode类的一个方法，用于将当前任务节点及其子节点的信息转化为字典形式。在转化过程中，排除了父节点、子节点和id这三个属性。

该函数返回一个字典，包含了当前任务节点的所有属性信息，以及子节点的信息列表。

**注意**：在使用该函数时，需要确保当前任务节点已经设置了父节点和子节点的关系。

**输出示例**：一个可能的返回值的示例
{
    "name": "Task1",
    "status": "DOING",
    "goal": "完成任务1",
    "conclusion": "任务1已完成",
    "id": "1",
    "children": [
        {
            "name": "Task1.1",
            "status": "DOING",
            "goal": "完成任务1.1",
            "conclusion": "任务1.1已完成",
            "id": "1.1",
            "children": []
        },
        {
            "name": "Task1.2",
            "status": "DOING",
            "goal": "完成任务1.2",
            "conclusion": "任务1.2已完成",
            "id": "1.2",
            "children": []
        }
    ]
}
## FunctionDef pid
**pid函数**: 这个函数的功能是返回当前计划节点的唯一标识符。

该函数用于计划节点对象，用于生成当前计划节点的唯一标识符。如果当前节点没有父节点，则返回"1"作为标识符。否则，返回父节点的标识符加上当前节点在父节点子节点列表中的索引加1。

该函数在计划节点对象的代码中被调用，用于生成计划树的字符串表示。计划树是一个由计划节点组成的层次结构，用于表示计划的执行顺序和关系。在计划树的字符串表示中，每个节点都会显示其唯一标识符、名称、目标和状态等信息。通过调用该函数，可以为每个节点生成其唯一标识符，以便在计划树中进行标识和查找。

**注意**: 该函数依赖于计划节点对象的父节点和子节点属性，因此在调用该函数之前，需要确保计划节点对象已经正确设置了父节点和子节点。

**输出示例**:
```
1
1.1
1.2
1.2.1
1.2.2
```
## FunctionDef depth
**depth函数**: 这个函数的功能是计算当前节点在树中的深度。

该函数接受一个参数self，表示当前节点对象。函数内部通过判断当前节点是否有父节点来确定当前节点在树中的深度。如果当前节点没有父节点，说明它是树的根节点，深度为1。否则，通过递归调用父节点的depth函数，并将结果加1，得到当前节点的深度。

**注意**: 使用该代码时需要注意以下几点:
- 该函数必须作为节点对象的方法进行调用。
- 调用该函数时，需要保证节点对象的父节点属性(father)已经正确设置。

**输出示例**: 假设当前节点的深度为3，调用depth函数的返回值为3。
## FunctionDef root
**root函数**: 该函数的功能是获取当前计划节点（PlanNode）的根节点。

该`root`函数是`PlanNode`类的一个成员方法，用于获取当前节点的根节点。在一个树形结构中，根节点是没有父节点的顶级节点。此函数通过递归的方式向上遍历，直到找到根节点。

具体来说，函数首先检查当前节点的`father`属性是否为`None`。如果为`None`，说明当前节点就是根节点，直接返回当前节点（`self`）。如果不是，函数将继续调用当前节点的父节点的`root`方法，这样递归地向上查找，直到找到根节点为止。

在项目中，`root`函数被定义在`XAgent/models/plan.py`文件中，并且在同一文件中被调用。由于这个函数是递归调用的，它不需要额外的参数，也不会在其他地方被直接调用。

**注意**：在使用`root`函数时，需要确保节点之间的父子关系已经正确建立，否则可能会导致无限递归或者返回错误的节点。

**输出示例**：
假设我们有以下的计划节点树结构：

```
   Root
   /  \
  A    B
 / \
C   D
```

如果我们从节点C调用`root`函数，返回值将是指向Root节点的引用。如果我们从Root节点调用`root`函数，它将返回自身的引用，因为Root节点没有父节点。
## FunctionDef add_child
**add_child函数**：此函数的功能是将一个子节点添加到当前节点的子节点列表中。

该函数接受两个参数：child和pos。child参数是一个PlanNode对象，表示要添加的子节点。pos参数是一个整数，默认值为-1，表示要插入的位置。

在函数内部，首先将child节点的父节点设置为当前节点self。然后根据pos的值进行判断，如果pos为-1，则将child节点添加到当前节点的子节点列表末尾；如果pos不为-1，则将child节点插入到当前节点的子节点列表的pos位置。

**注意**：使用此代码的注意事项如下：
- 确保传入的child参数是一个有效的PlanNode对象。
- 如果指定了pos参数，确保pos的值在合理的范围内，不会导致索引越界错误。
## FunctionDef delete_child
**delete_child 函数**: 该函数的功能是删除一个子节点。

该函数定义在 `Plan` 类中，用于删除当前计划节点的一个子节点。函数接受一个参数 `child`，该参数是一个 `PlanNode` 类型的对象，代表要删除的子节点。

详细代码分析如下：

1. `child.father = None`: 这行代码将子节点的 `father` 属性设置为 `None`，即断开子节点与其父节点的关联。在面向对象的设计中，这通常是为了确保对象之间的关系是正确的，避免出现悬挂引用。

2. `self.children.remove(child)`: 这行代码从当前节点的 `children` 列表中移除指定的子节点 `child`。`self.children` 是一个列表，存储了所有的子节点。使用 `remove` 方法可以从列表中删除一个元素，如果元素不存在于列表中，将会抛出 `ValueError` 异常。

**注意**：

- 在调用 `delete_child` 函数之前，确保 `child` 确实是当前节点的子节点，否则 `remove` 方法会抛出异常。
- 删除子节点后，如果需要对子节点进行进一步的处理（例如释放资源或通知其他对象），应在调用 `delete_child` 之后进行。
- 该函数不返回任何值，它的作用仅限于修改 `Plan` 对象的内部状态。
***
# ClassDef PlanTree
**PlanTree函数**：这个类的功能是为给定的任务创建一个计划树。

PlanTree类表示一个计划树，它包含了一个根节点和一些子节点。计划树用于组织和管理任务的执行顺序。它提供了一些方法来操作和查询计划树的节点。

- **get_task(id: str)方法**：根据任务的id获取对应的任务节点。
  - 参数：
    - id: str - 任务的id，格式为"1.2.3"，表示根节点的第2个子节点的第3个子节点。
  - 返回值：
    - task: PlanNode - 对应的任务节点。
  - 注意：
    - 如果id不合法（不以"1"开头），会抛出ValueError异常。

- **traversal()方法**：遍历计划树，返回按照中序遍历的节点列表。
  - 返回值：
    - traversal: list[PlanNode] - 按照中序遍历的节点列表。

- **get_next()方法**：获取下一个待执行的子任务。
  - 返回值：
    - Next subtask in the queue: PlanNode | None - 下一个待执行的子任务节点，如果没有待执行的子任务则返回None。

- **get_current()方法**：获取当前正在执行的子任务。
  - 返回值：
    - Current subtask in the queue: PlanNode | None - 当前正在执行的子任务节点，如果没有正在执行的子任务则返回None。

- **get_remining()方法**：获取剩余的子任务列表。
  - 返回值：
    - Remaining subtasks: list[PlanNode] - 剩余的子任务列表。

- **model_dump()方法**：将计划树转换为字典格式的数据。
  - 返回值：
    - d: dict - 字典格式的计划树数据。

- **__str__()方法**：将计划树转换为字符串格式。
  - 返回值：
    - str: str - 字符串格式的计划树。

**注意**：
- PlanTree类继承自BaseContext类。
- PlanTree类的构造函数需要传入一个根节点。
- PlanTree类的方法主要用于操作和查询计划树的节点。
- PlanTree类的方法可以帮助用户获取和管理计划树中的任务节点。
- PlanTree类的方法可以根据任务的id获取对应的任务节点，遍历计划树，获取下一个待执行的子任务，获取当前正在执行的子任务，获取剩余的子任务列表，将计划树转换为字典格式的数据，将计划树转换为字符串格式。

**输出示例**：
```
[id] 1
[name] Task 1
[goal] Goal 1
[status] TODO
[milestones]
- Milestone 1
- Milestone 2
[submission]
Submission: This is a submission for Task 1.
[conclusion]
Conclusion: This is a conclusion for Task 1.

[id] 1.1
[name] Task 1.1
[goal] Goal 1.1
[status] DOING

[id] 1.1.1
[name] Task 1.1.1
[goal] Goal 1.1.1
[status] SUCCESS

[id] 1.1.2
[name] Task 1.1.2
[goal] Goal 1.1.2
[status] FAIL
```
以上是计划树的字符串表示形式的示例。每个节点包含了id、name、goal、status等信息，以及milestones、submission、conclusion等附加信息。节点之间使用空行分隔。
## FunctionDef get_task
**get_task函数**: 此函数的功能是根据给定的任务ID检索并返回计划树中的特定任务节点。

get_task函数是一个用于从计划树中检索特定任务节点的方法。它接受一个字符串参数`id`，该参数代表了任务在计划树中的唯一标识符。这个标识符是由点号`.`分隔的数字序列，其中每个数字代表了在当前层级中的子节点索引。

函数首先将传入的`id`字符串分割成索引数组`idxes`。然后，它从计划树的根节点开始遍历，按照索引数组中的顺序逐层向下寻找子节点。如果在任何时候给定的索引不在有效范围内，或者`id`的格式不正确（例如，不是以'1'开头），函数将抛出一个`ValueError`异常。

在项目中调用此函数的场景中，函数用于执行工具调用时，根据工具调用中指定的目标任务ID来获取相应的任务节点。如果目标任务ID无效或找不到对应的任务节点，将返回错误状态码和错误信息。此外，还会根据不同的操作（如split、add、delete等）对找到的任务节点进行相应的操作。

**注意**:
- 传入的任务ID必须是有效的，且以'1'开头，否则会抛出`ValueError`异常。
- 任务ID中的索引应该是从1开始的，因为在实际的子节点列表中，索引是从0开始的。因此，在遍历子节点时，需要将索引减去1。
- 如果任务ID对应的节点不存在，函数将无法返回有效的任务节点。

**输出示例**:
假设有一个计划树，其结构如下：
```
1 (根节点)
├── 1.1 (子节点)
├── 1.2 (子节点)
│   ├── 1.2.1 (子节点)
│   └── 1.2.2 (子节点)
└── 1.3 (子节点)
```
如果调用`get_task('1.2.1')`，函数将返回表示节点1.2.1的任务节点对象。如果调用`get_task('1.4')`，由于不存在索引为4的子节点，函数将抛出`ValueError`异常。
## FunctionDef traversal
**traversal函数**: 此函数的功能是遍历计划树。

`traversal`函数是`Plan`类的一个方法，用于执行计划树的遍历操作。计划树是由多个`PlanNode`节点组成的树状结构，每个节点代表一个计划中的子任务。此函数通过递归的方式，按照中序遍历的顺序访问树中的所有节点，并将它们按遍历顺序收集到一个列表中。

函数定义如下：
```python
def traversal(self) -> list[PlanNode]:
    """Performs a traversal of the plan tree.

    Returns:
        All plan tree node in the tree in inorder.
    """
    traversal = []

    def traversal_node(node: PlanNode):
        traversal.append(node)
        for child in node.children:
            traversal_node(child)
    traversal_node(self.root)
    return traversal
```

在这段代码中，`traversal`是一个局部变量，用于存储遍历过程中访问的节点。`traversal_node`是一个内部函数，它接受一个`PlanNode`类型的参数`node`，将其添加到`traversal`列表中，并递归地对其子节点进行相同的操作。这个过程从树的根节点`self.root`开始。

在项目中，`traversal`函数被用于多个场景，例如：
- `get_next`方法中，用于获取状态为`TODO`的下一个子任务节点。
- `get_current`方法中，用于获取状态为`DOING`的当前子任务节点，如果没有正在进行的任务，则返回最近一个状态为`SUCCESS`或`FAIL`的节点。
- `get_remining`方法中，用于获取所有状态为`TODO`的剩余子任务节点。
- `__str__`方法中，用于生成计划树的字符串表示，其中包括每个节点的详细信息。

**注意**：
- 使用`traversal`函数时，需要确保计划树的结构已经正确构建，且每个节点都是`PlanNode`类型。
- 由于`traversal`函数使用了递归，对于非常深或非常大的树，可能会遇到栈溢出的问题。在实际应用中，应当注意树的规模和深度。

**输出示例**：
假设有一个简单的计划树，根节点下有两个子节点，那么`traversal`函数的返回值可能如下所示：
```python
[<PlanNode root>, <PlanNode child1>, <PlanNode child2>]
```
这个列表中包含了计划树中所有的节点，按照中序遍历的顺序排列。
### FunctionDef traversal_node
**traversal_node 函数**: 该函数的功能是遍历计划树中的节点。

该`traversal_node`函数是一个递归函数，用于遍历计划树（Plan Tree）中的所有节点，并将它们按照遍历的顺序收集起来。这个函数定义在`XAgent/models/plan.py`文件中，通常作为一个内部辅助函数来使用，它的具体作用是从给定的节点开始，递归地遍历该节点的所有子节点，并将遍历到的节点依次添加到一个列表中。

函数接收一个参数`node`，这个参数是`PlanNode`类型的实例，代表当前正在遍历的节点。`PlanNode`是计划树中的一个节点，它可能有多个子节点，这些子节点存储在`node.children`列表中。

在`traversal_node`函数的实现中，首先将当前节点`node`添加到全局变量`traversal`列表中。然后，函数遍历当前节点的所有子节点，对每一个子节点，递归地调用`traversal_node`函数。

这个函数被调用在`traversal`方法中，该方法是`Plan`类的一个成员方法。`traversal`方法的目的是生成并返回一个包含计划树中所有节点的列表。在这个方法中，首先创建了一个空列表`traversal`，然后调用`traversal_node`函数，从计划树的根节点`self.root`开始遍历整棵树。最后，`traversal`方法返回包含了整棵树节点的`traversal`列表。

**注意**：
- `traversal_node`函数是一个递归函数，因此在使用时需要注意递归深度，以避免可能的栈溢出错误。
- 由于`traversal_node`函数使用了外部变量`traversal`，在并发环境下使用时需要注意线程安全问题。
- 这个函数的设计是为了内部使用，因此在调用时需要确保正确地初始化`traversal`列表，并在递归调用结束后正确地处理这个列表。
## FunctionDef get_next
**get_next函数**: 此函数的功能是获取队列中的下一个子任务。

`get_next`函数是一个成员方法，它属于一个计划（Plan）对象，用于从任务队列中获取下一个待处理的子任务。这个函数没有接收任何参数，并且返回一个`PlanNode`类型的对象或者`None`。

具体来说，`get_next`函数首先调用`self.traversal()`方法来获取当前计划中所有的子任务节点，这些节点被组织成一个列表。然后，函数遍历这个列表，检查每个节点的状态。如果节点的状态是`TaskStatusCode.TODO`（即待办状态），那么这个节点就是下一个需要处理的子任务，函数将返回这个节点。如果遍历完所有节点后都没有找到待办状态的节点，函数将返回`None`，表示没有更多的待办子任务。

在项目中，`get_next`函数被`XAgent/engines/plan.py`文件中的`run`方法调用。在`run`方法的执行过程中，它用于循环获取计划树中的下一个待处理的子任务。每次循环时，`run`方法会检查是否存在待处理的子任务。如果存在，它会更新该子任务的状态为`TaskStatusCode.DOING`（即正在处理状态），然后继续执行相应的处理步骤。如果`get_next`返回`None`，则表示所有子任务都已处理完毕，循环结束。

**注意**：
- 使用`get_next`函数时，需要确保计划树已经正确初始化，并且子任务的状态已经被设置。
- 当没有更多待办的子任务时，`get_next`函数将返回`None`，调用者需要对此进行检查，以避免空指针错误。

**输出示例**：
假设计划树中有三个子任务节点，状态分别为`TaskStatusCode.TODO`、`TaskStatusCode.DOING`和`TaskStatusCode.DONE`，那么第一次调用`get_next`函数将返回第一个`TaskStatusCode.TODO`状态的节点。如果所有子任务都不是`TaskStatusCode.TODO`状态，那么调用`get_next`函数将返回`None`。
## FunctionDef get_current
**get_current函数**: 此函数的功能是获取队列中的下一个子任务。

该`get_current`函数是一个成员函数，通常属于一个任务计划（Plan）对象。它的主要作用是遍历任务计划中的子任务节点（PlanNode），并返回当前正在执行的子任务，或者最近完成（无论成功或失败）的子任务。

详细代码分析如下：

1. 函数首先调用`self.traversal()`方法来获取一个包含所有子任务节点的列表，这个列表按照子任务的执行顺序排列。

2. 然后，函数遍历这个列表，检查每个子任务节点的状态。如果发现有子任务的状态是`TaskStatusCode.DOING`（表示该子任务正在执行中），则立即返回这个子任务节点。

3. 如果没有正在执行的子任务节点，函数将反向遍历列表（即从最后一个子任务开始向前检查），寻找状态为`TaskStatusCode.SUCCESS`（表示子任务执行成功）或`TaskStatusCode.FAIL`（表示子任务执行失败）的子任务节点。找到后，返回这个节点。

4. 如果遍历完所有子任务节点后都没有找到正在执行或已完成的子任务，则函数返回`None`。

**注意**：
- 使用此函数时，需要确保`self.traversal()`方法能够正确返回子任务节点列表。
- 子任务节点的状态应该由外部逻辑正确更新，以保证`get_current`函数能够返回正确的结果。

**输出示例**：
假设有一个任务计划对象，其中包含若干个子任务节点，且当前有一个子任务正在执行中。调用`get_current`函数可能会返回如下结果：

```python
<PlanNode object at 0x7f8e2c0b7fd0>
```

这表示函数返回了一个内存地址为`0x7f8e2c0b7fd0`的`PlanNode`对象，该对象代表当前正在执行的子任务。如果没有正在执行或已完成的子任务，则返回值为`None`。
## FunctionDef get_remining
**get_remining函数**: 此函数的功能是获取剩余的子任务。

`get_remining`函数是`Plan`类的一个方法，它的作用是从当前的任务执行计划中检索出所有状态为待办（TODO）的子任务。这个方法对于执行引擎来说非常重要，因为它可以用来确定哪些任务还没有开始执行，从而可以继续安排这些任务的执行。

具体来说，该函数首先调用`self.traversal()`方法来获取当前计划中的所有任务节点，然后通过列表推导式筛选出其中状态为`TaskStatusCode.TODO`的节点，即还未执行的任务节点。这些节点被封装在`PlanNode`对象中，代表了计划中的一个个具体的任务。

在项目中的调用情况如下：

在`XAgent/engines/plan.py`文件中的`step`函数中，`get_remining`被用来获取执行追踪（`exec_track`）中计划树（`plan_tree`）的剩余任务。`step`函数是执行引擎的一个步骤函数，它处理单个任务节点的执行，并且在执行结束后，需要检查是否还有剩余的任务需要执行。通过调用`get_remining`，`step`函数能够得到一个包含所有剩余任务的列表，并据此判断当前处理的任务节点是否是最后一个节点。

**注意**：
- 在使用`get_remining`函数时，需要确保`Plan`类的实例已经正确初始化，并且包含了一个有效的任务执行计划。
- 该函数返回的是一个`PlanNode`对象列表，每个对象代表一个待办的任务节点。
- 确保`TaskStatusCode`枚举类中包含`TODO`状态，以便函数能够正确筛选出待办任务。

**输出示例**：
假设当前计划中有三个任务节点，其中两个的状态为`TODO`，一个的状态为`DOING`，那么`get_remining`函数的返回值可能如下所示：
```python
[
    PlanNode(...),  # 第一个待办任务节点
    PlanNode(...)   # 第二个待办任务节点
]
```
每个`PlanNode`对象都包含了任务节点的详细信息，如任务ID、目标、状态等。
## FunctionDef model_dump
**model_dump函数**: 此函数的功能是导出模型的层次结构数据，并为每个节点分配唯一的ID。

model_dump函数是一个成员方法，通常存在于表示计划或任务树的对象中。此函数的主要作用是将模型的层次结构数据转储为一个字典格式，同时为树中的每个节点分配一个唯一的标识符（ID）。这个ID是通过节点在树中的位置来确定的，以便于在后续的处理中可以唯一地引用每个节点。

函数的内部实现包含了一个嵌套的辅助函数add_id_to_d，它负责递归地遍历模型的每个子节点，并为它们添加ID。ID的格式是一个字符串，如果节点是根节点，ID就是索引值加1（因为索引是从0开始的），如果节点不是根节点，ID则是父节点ID与当前节点的索引值加1拼接而成，中间用点号"."分隔。

在项目中，model_dump函数被调用于record.py文件中的_write_plan_tree异步方法。在该方法中，model_dump函数用于获取计划树（plan_tree）的结构数据，并根据配置将这些数据写入文件或数据库。如果配置了文件记录，它会将数据序列化为JSON格式并写入"plan_tree.json"文件。如果配置了数据库记录，它会将数据存储在记录对象的plan_tree属性中，并异步保存到数据库。

**注意**：
- 在调用model_dump函数之前，需要确保模型的层次结构已经正确构建。
- 生成的ID是基于节点在树中的位置，因此在树结构发生变化时，节点的ID也可能发生变化。
- 在写入文件时，使用了orjson.dumps进行序列化，这意味着需要确保模型的数据可以被orjson正确处理。

**输出示例**：
```json
{
  "id": "1",
  "children": [
    {
      "id": "1.1",
      "children": [
        {
          "id": "1.1.1",
          "children": []
        },
        {
          "id": "1.1.2",
          "children": []
        }
      ]
    },
    {
      "id": "1.2",
      "children": []
    }
  ]
}
```
在这个示例中，根节点的ID为"1"，它有两个子节点，分别分配了ID "1.1" 和 "1.2"。节点 "1.1" 还有两个子节点，分别分配了ID "1.1.1" 和 "1.1.2"。每个节点还可能包含其他属性，但在这个输出示例中省略了以保持简洁。
### FunctionDef add_id_to_d
**add_id_to_d函数**: 此函数的功能是为字典结构中的每个元素添加一个唯一的ID标识。

此函数`add_id_to_d`接受三个参数：`sub_d`是一个字典对象，代表当前需要添加ID的子结构；`prefix`是一个字符串，表示当前子结构的父级ID前缀；`idx`是一个整数，表示当前子结构在其父级结构中的索引。

函数的主要逻辑如下：
1. 首先，函数检查`prefix`是否为空字符串。如果是，说明当前子结构是最顶层的结构，它的ID应该是其索引值加1（因为通常索引是从0开始的，而ID通常从1开始）。如果`prefix`不为空，说明当前子结构不是最顶层的结构，它的ID应该是父级ID加上"."和其索引值加1。
2. 然后，函数遍历当前子结构的`children`字段，这个字段应该是一个列表，包含了所有子级结构的字典。对于每一个子级结构，函数递归调用`add_id_to_d`，传入子级结构、当前子结构的ID作为新的前缀，以及子级结构在列表中的索引。

在项目中，`add_id_to_d`函数被调用于`model_dump`方法中。`model_dump`方法首先从根结构开始，生成一个包含所有子结构的字典，然后调用`add_id_to_d`函数为这个字典结构中的每个元素添加ID。这样，每个元素都会有一个唯一的标识，这在处理复杂的嵌套结构时非常有用，比如在构建树形数据结构或者执行递归操作时。

**注意**：
- 确保传入的`sub_d`字典对象包含`children`字段，且该字段是一个列表，列表中的元素也是字典，否则在执行函数时会抛出异常。
- 由于此函数是递归调用的，需要注意递归深度，以避免在处理非常深的嵌套结构时出现栈溢出的问题。
- 函数中使用的ID生成规则（即前缀+索引）需要与项目中其他部分对ID的处理保持一致，以确保ID的唯一性和一致性。
## FunctionDef __str__
**__str__函数**: 该函数的功能是打印计划树。

该函数`__str__`定义在`Plan`类中，用于生成并返回一个描述计划树的字符串。计划树由多个`PlanNode`节点组成，每个节点代表计划中的一个步骤或者目标。

首先，函数通过调用`self.traversal()`方法获取计划树的遍历结果，该结果是一个包含`PlanNode`对象的列表。然后，函数遍历这个列表，对于每个节点，它将创建一个描述节点的字符串列表`node_des`。

对于每个`PlanNode`节点，函数会添加以下信息到`node_des`列表中：
- 节点的ID，使用`[id]`标签。
- 节点的名称，使用`[name]`标签。
- 节点的目标，使用`[goal]`标签。
- 节点的状态，使用`[status]`标签。

如果节点有里程碑（`milestones`），则会将每个里程碑前加上一个短横线（`-`）并添加到描述中，使用`[milestones]`标签。

如果节点有先前的批评（`prior_criticism`），则会将这些批评添加到描述中，使用`[prior criticism]`标签。

如果节点有提交物（`submission`），则会将提交物的字符串表示形式（可能是多行）添加到描述中，并且每行前会添加一个制表符（`\t`），使用`[submission]`标签。

如果节点有结论（`conclusion`），则会以与提交物相同的方式处理，并使用`[conclusion]`标签。

最后，函数将所有节点的描述字符串列表`node_des`连接起来，每个节点描述之间用两个换行符（`\n\n`）分隔，并返回最终的字符串。

**注意**：在使用这段代码时，需要确保`PlanNode`类中的`pid`、`name`、`goal`、`status`、`milestones`、`prior_criticism`、`submission`和`conclusion`属性已经正确地定义和初始化，以便函数能够正确地访问和格式化这些信息。

**输出示例**:
```
[id] 1
[name] 起始节点
[goal] 完成项目启动
[status] 完成

[id] 2
[name] 研究市场
[goal] 收集市场数据
[status] 进行中
[milestones]
- 市场调研报告
- 竞争对手分析

[id] 3
[name] 产品设计
[goal] 完成产品原型设计
[status] 待开始
[prior criticism] 设计初稿不够创新
[submission]
	设计文档v1.0
	用户反馈报告
[conclusion]
	设计方案已经过审批
	预计下一阶段开始日期：2023-04-15
```
以上输出示例展示了一个可能的计划树的字符串表示，其中包含了三个节点的详细信息。
***
